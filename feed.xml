<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://thirstydeveloper.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://thirstydeveloper.io/" rel="alternate" type="text/html" /><updated>2021-01-30T13:44:29+00:00</updated><id>https://thirstydeveloper.io/feed.xml</id><title type="html">thirstydeveloper</title><subtitle>Infrastructure-as-Code-as-a-Team</subtitle><author><name>Chris Kent</name></author><entry><title type="html">Terraform Skeleton Part 3: AWS Backend</title><link href="https://thirstydeveloper.io/tf-skeleton/2021/01/28/part-3-aws-backend.html" rel="alternate" type="text/html" title="Terraform Skeleton Part 3: AWS Backend" /><published>2021-01-28T11:00:00+00:00</published><updated>2021-01-28T11:00:00+00:00</updated><id>https://thirstydeveloper.io/tf-skeleton/2021/01/28/part-3-aws-backend</id><content type="html" xml:base="https://thirstydeveloper.io/tf-skeleton/2021/01/28/part-3-aws-backend.html">&lt;p&gt;Terraform uses &lt;a href=&quot;https://www.terraform.io/docs/state/index.html&quot;&gt;state&lt;/a&gt; files to track the resources it creates back to resource definitions in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tf&lt;/code&gt; files. Each deployment has its own state. State is stored according to the &lt;a href=&quot;https://www.terraform.io/docs/configuration/blocks/backends/index.html&quot;&gt;backend&lt;/a&gt; configured for the deployment. Terraform uses a &lt;a href=&quot;https://www.terraform.io/docs/backends/types/local.html&quot;&gt;local backend&lt;/a&gt; for storing state on the local filesystem by default, which is what we’ve been using for &lt;a href=&quot;/2021/01/17/part-1-organizing-terragrunt.html&quot;&gt;part 1&lt;/a&gt; and &lt;a href=&quot;/tf-skeleton/2021/01/23/part-2-variables.html&quot;&gt;part 2&lt;/a&gt; of the &lt;a href=&quot;/series/tf-skeleton.html&quot;&gt;terraform skeleton series&lt;/a&gt;.&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; This works fine for a simple demonstration but is insufficient for production use because:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;You can only run terraform commands on your deployments from that one machine&lt;/li&gt;
  &lt;li&gt;There are no built-in backups on your state files; if they’re lost, you’re going to have a bad day&lt;/li&gt;
  &lt;li&gt;There’s no built-in versioning of your state files, which can be handy for recovering from more advanced terraform operations gone wrong&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;While you can commit the state files into your git repository for achieving distribution across team members, backups, and versioning, that isn’t a good idea because:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;State files can include sensitive information you might not want in version control&lt;/li&gt;
  &lt;li&gt;If multiple team members make changes affecting the same state file, you’ll wind up with a mess of multiple incomplete state files needing to be merged&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://www.terraform.io/docs/state/remote.html&quot;&gt;Remote state&lt;/a&gt; storage is built in to terraform and solves these problems, making it easy for teams to collaborate on the same deployments. Terragrunt provides further enhancements that make working with remote state even easier. Today, we’ll add remote state to the skeleton using terragrunt, &lt;a href=&quot;https://aws.amazon.com/s3/&quot;&gt;S3&lt;/a&gt;, and &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt;. This will give us a simple foundation to build on.&lt;/p&gt;

&lt;h1 id=&quot;goals&quot;&gt;Goals&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;Our skeleton stores state remotely such that multiple teammates can run terraform commands&lt;/li&gt;
  &lt;li&gt;State files are stored in a directory structure matching our deployments&lt;/li&gt;
  &lt;li&gt;Locks are in place around state manipulation to avoid corruption due to concurrent terraform command executions&lt;/li&gt;
  &lt;li&gt;State is stored securely, with encryption, versioning, and logging enabled&lt;/li&gt;
  &lt;li&gt;Remote state configuration is DRY - defined once and reused across deployments&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If you prefer to jump to the end, the code implementing the final result is available on &lt;a href=&quot;https://github.com/thirstydeveloper/terraform-terragrunt-skeleton/tree/release/1.2&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;setup&quot;&gt;Setup&lt;/h1&gt;

&lt;p&gt;You will need:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;An AWS account&lt;/li&gt;
  &lt;li&gt;Credentials for that account configured in the terminal used for running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt&lt;/code&gt; commands&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;the-s3-backend&quot;&gt;The S3 Backend&lt;/h1&gt;

&lt;p&gt;Remote state can be accomplished in many different ways with terraform. The teams I support tend to have an Amazon Web Services footprint already, and therefore I typically use terraform’s &lt;a href=&quot;https://www.terraform.io/docs/backends/types/s3.html&quot;&gt;S3 backend&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The S3 backend stores your state files in S3 and retrieves them for stateful terraform commands. This meets the distribution, versioning, and encryption requirements we require. To avoid corruption from concurrent terraform commands, the S3 backend uses a DynamoDB table to manage lock files. Stateful terraform commands first obtain a lock from the DynamoDB table, effectively single-threading commands operating on the same state file.&lt;/p&gt;

&lt;p&gt;We’ll focus on using the S3 backend today.&lt;/p&gt;

&lt;h1 id=&quot;backend-configuration-with-terraform&quot;&gt;Backend Configuration with Terraform&lt;/h1&gt;

&lt;p&gt;Terraform backends are configured using a block in the stack’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tf&lt;/code&gt; files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HCL&quot;&gt;terraform {
  backend &quot;s3&quot; {
    bucket = &quot;terraform-skeleton-state&quot;
    key    = &quot;something/unique/to/the/stack&quot;
    region = &quot;us-east-1&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This inline configuration is less than ideal. First, you have to configure the backend for every stack definition (i.e., in every directory under our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/stacks&lt;/code&gt;), leading to a lot of duplication. Second, you cannot use interpolation in the backend block to configure it using variables, locals, or data source attributes. A lack of interpolation can be problematic if you want to use different buckets for different environments for example, since we have multiple deployments (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/app/dev/test-stack&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/app/test/test-stack&lt;/code&gt;) sharing the same &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/stack/app/test-stack&lt;/code&gt; files.&lt;/p&gt;

&lt;p&gt;Terraform provides several ways to work around these limitations through &lt;a href=&quot;https://www.terraform.io/docs/configuration/backend.html#partial-configuration&quot;&gt;partial configuration&lt;/a&gt;. This allows you to omit properties from the backend block and instead provide them through an out-of-band mechanism such as a configuration file, a command-line option, or interactively on the command-line. With partial configuration, you could, for example, omit the bucket property in the configuration above, and instead pass it through one of the mentioned mechanisms to achieve different buckets for different environments.&lt;/p&gt;

&lt;p&gt;Partial configuration, although a step in the right direction, still requires you to figure out how you’re going to manage the backend configuration properties. If using configuration files, where will those be stored and distributed to the team? How will you ensure every terraform command receives the necessary command-line properties with the correct values? This more or less forces you to use a build tool for your terraform commands (e.g., a makefile) to achieve consistency/reproducibility. While a build tool isn’t necessarily a bad thing, it strikes me as unusual to require it for remote state, a seemingly basic and fundamental capability.&lt;/p&gt;

&lt;p&gt;Fortunately, terragrunt gives us a way to make remote state usage easy for anyone on the team.&lt;/p&gt;

&lt;h1 id=&quot;backend-configuration-with-terragrunt&quot;&gt;Backend Configuration with Terragrunt&lt;/h1&gt;

&lt;p&gt;With terragrunt, you can configure your backend within a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt.hcl&lt;/code&gt;, or in our case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt;. Terragrunt then generates the necessary terraform backend configuration based on what you specify. Configuring remote state inside &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; means every deployment will receive the backend configuration by way of terragrunt’s include mechanism. This removes all duplication of remote state configuration from the stacks.&lt;/p&gt;

&lt;p&gt;Additionally, the remote state block supports interpolation, allowing each deployment to share common parts of the remote state configuration while having other parts be unique. For instance, every deployment can share the same bucket for their state files but use a different prefix within that bucket.&lt;/p&gt;

&lt;p&gt;Using terragrunt’s remote state configuration is &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/features/keep-your-remote-state-configuration-dry/&quot;&gt;well documented by Gruntwork&lt;/a&gt;. Here’s how we can add it to our skeleton.&lt;/p&gt;

&lt;h2 id=&quot;implementation&quot;&gt;Implementation&lt;/h2&gt;

&lt;p&gt;Add a &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/config-blocks-and-attributes/#remote_state&quot;&gt;remote_state&lt;/a&gt; block to our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; to generate an s3 backend configuration:&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;--- a/deployments/root.hcl
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/deployments/root.hcl
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -39,6 +40,24 @@&lt;/span&gt; locals {
 # environment variables
 inputs = local.merged_config

+remote_state {
&lt;span class=&quot;gi&quot;&gt;+  backend = &quot;s3&quot;
+  generate = {
+    path      = &quot;backend.tf&quot;
+    if_exists = &quot;overwrite&quot;
+  }
+  config = {
+    bucket  = &quot;terraform-skeleton-state&quot;
+    region  = &quot;us-east-1&quot;
+    encrypt = true
+
+    key = &quot;${dirname(local.relative_deployment_path)}/${local.stack}.tfstate&quot;
+
+    dynamodb_table            = &quot;terraform-skeleton-state-locks&quot;
+    accesslogging_bucket_name = &quot;terraform-skeleton-state-logs&quot;
+  }
+}
+
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This approach uses:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A single bucket, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform-skeleton-state&lt;/code&gt;, for all deployment state files&lt;/li&gt;
  &lt;li&gt;A key/prefix unique to each deployment based on the relative path from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; file&lt;/li&gt;
  &lt;li&gt;A corresponding DynamoDB lock table, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform-skeleton-state-locks&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;A logging bucket, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform-skeleton-state-logs&lt;/code&gt;, for logging all S3 access requests to out state bucket&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how-this-works&quot;&gt;How This Works&lt;/h2&gt;

&lt;p&gt;Terragrunt executes terraform commands from a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.terragrunt-cache&lt;/code&gt; directory. Before executing terraform, terragrunt populates the cache with:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Any files in the current deployment directory (location of your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt.hcl&lt;/code&gt; file)&lt;/li&gt;
  &lt;li&gt;The stack files in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform.source&lt;/code&gt; directory specified in our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Files from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generate&lt;/code&gt; blocks defined in the HCL files&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The last step above is what translates the generate block defined in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;backend.tf&lt;/code&gt; file for each stack containing the appropriate terraform backend configuration.&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;buckettable-initialization&quot;&gt;Bucket/Table Initialization&lt;/h2&gt;

&lt;p&gt;By using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remote_state&lt;/code&gt; block in our HCL files, we allow terragrunt to manage the creation of the S3 bucket and DynamoDB table for us.&lt;/p&gt;

&lt;p&gt;Terragrunt will:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Automatically create both buckets and/or lock table for you if it does not exist&lt;/li&gt;
  &lt;li&gt;Configure the state bucket (but not the logs bucket) with
    &lt;ul&gt;
      &lt;li&gt;Versioning and encryption enabled&lt;/li&gt;
      &lt;li&gt;Public access disabled&lt;/li&gt;
      &lt;li&gt;Enforcing TLS-only access&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Enable encryption on the lock table&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;activating-remote-state&quot;&gt;Activating Remote State&lt;/h2&gt;

&lt;p&gt;Switching from local state to remote state requires running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt init&lt;/code&gt; on each deployment.&lt;/p&gt;

&lt;p&gt;The first init will prompt you to create the buckets and/or dynamo table if they don’t exist:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Initializing remote state for the s3 backend
Remote state S3 bucket terraform-skeleton-state does not
exist or you don't have permissions to access it.
Would you like Terragrunt to create it? (y/n)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Every init will then prompt you to copy your existing local state to the new remote backend:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[terragrunt] 2020/12/13 10:04:56 Initializing remote state for the s3 backend
[terragrunt] 2020/12/13 10:04:57 Running command: terraform init

Initializing the backend...
Do you want to copy existing state to the new backend?
  Pre-existing state was found while migrating the previous &quot;local&quot; backend to the
  newly configured &quot;s3&quot; backend. No existing state was found in the newly
  configured &quot;s3&quot; backend. Do you want to copy this state to the new &quot;s3&quot;
  backend? Enter &quot;yes&quot; to copy and &quot;no&quot; to start with an empty state.

  Enter a value:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, although this shouldn’t be necessary, I’ve had to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rm -rf&lt;/code&gt; the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.terragrunt-cache&lt;/code&gt; directory inside each deployment for terragrunt commands to work after the migration.&lt;/p&gt;

&lt;p&gt;After activating remote state for all deployments, we can list our state bucket and see the state files nicely organized:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;➜ aws s3 &lt;span class=&quot;nb&quot;&gt;ls&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--recursive&lt;/span&gt; terraform-skeleton-state
2020-12-12 07:38:39       1154 app/dev/test-stack.tfstate
2020-12-13 10:22:49       1148 app/prod/test-stack.tfstate
2020-12-13 10:22:34       1154 app/stage/test-stack.tfstate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;limitations&quot;&gt;Limitations&lt;/h2&gt;

&lt;p&gt;Using terragrunt’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remote_state&lt;/code&gt; block has several advantages:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It’s easy&lt;/li&gt;
  &lt;li&gt;It includes sensible security defaults for the state bucket and lock table&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While it is good enough for today’s skeleton, there are some limitations of the terragrunt approach worth covering:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Terragrunt lacks security defaults on the log bucket&lt;/p&gt;

    &lt;p&gt;If terragrunt creates the log bucket, it will not have encryption enabled and it will not have public access explicitly blocked. For this reason, you should strongly consider self-management of the log bucket. I tend to do this with a CloudFormation stack.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sometimes you don’t want auto-creation of the state bucket and lock table&lt;/p&gt;

    &lt;p&gt;Once I start distributing ownership of pieces of infrastructure to different teams, I want to control where state files are stored as much as possible, which means avoiding a situation where a team accidentally creates a new state bucket or lock table. Consistent state file storage makes it easier to audit infrastructure for compliance with team and organization standards using tools like &lt;a href=&quot;https://terraform-compliance.com/&quot;&gt;terraform-compliance&lt;/a&gt;. Easier auditing in turn makes it more palatable to push down infrastructure ownership responsibilities.&lt;/p&gt;

    &lt;p&gt;For a single team owning all infrastructure, however, auto-creation is likely safe enough.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Terragrunt doesn’t offer full control over the credentials used to access the terraform state&lt;/p&gt;

    &lt;p&gt;The &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/config-blocks-and-attributes/#remote_state&quot;&gt;remote_state&lt;/a&gt; block has a few fields for specifying a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;role_arn&lt;/code&gt; or AWS &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile&lt;/code&gt; to use for remote state access, but you can’t control things like &lt;a href=&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html&quot;&gt;IAM session tags&lt;/a&gt;, transitive tag usage, or assume role policies.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Terragrunt doesn’t offer full control over all fields on the buckets and table&lt;/p&gt;

    &lt;p&gt;While terragrunt applies sensible security defaults, you can’t control everything using its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;remote_state&lt;/code&gt; block. For example, you’ll need to self-manage if you need to specify specific KMS keys for encryption of the bucket or table. Similarly, if you want to set up replication of your terraform state bucket, self-management is the way to go.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h1&gt;

&lt;p&gt;The skeleton now supports multiple developers working on the infrastructure as a team, sharing a state file stored in S3 with contention resolved through a DynamoDB lock table. State is encrypted and versioned, and access to it is logged. Remote state is configured once, in the root.hcl, and reused across our stacks.&lt;/p&gt;

&lt;p&gt;Thus far, terragrunt has been running with whatever AWS credentials were configured in the shell at the time of execution.&lt;/p&gt;

&lt;p&gt;This isn’t ideal in a team setting because:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It could lead to “works on my machine problems” if developers have different configurations&lt;/li&gt;
  &lt;li&gt;It encourages running terraform with administrative-level permissions all the time for all developers working with it&lt;/li&gt;
  &lt;li&gt;Terraform state is sensitive and should be protected from modification except by a well-defined set of roles&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The next entry in the &lt;a href=&quot;/series/tf-skeleton.html&quot;&gt;terraform skeleton series&lt;/a&gt; will take a first step towards addressing these issues.&lt;/p&gt;

&lt;h1 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h1&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Terragrunt stores local state in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform.tfstate&lt;/code&gt; file located underneath the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.terragrunt-cache&lt;/code&gt; directory it creates within our deployment directory. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;The terragrunt remote state approach we cover here uses the newer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;generate&lt;/code&gt; option, which was &lt;a href=&quot;https://github.com/gruntwork-io/terragrunt/pull/1050&quot;&gt;added&lt;/a&gt; in terragrunt &lt;a href=&quot;https://github.com/gruntwork-io/terragrunt/releases/tag/v0.22.0&quot;&gt;v0.22.0&lt;/a&gt;. Before that version, terragrunt wouldn’t generate a backend.tf file but would instead pass CLI arguments to the terraform command, making use of terraform’s partial configuration implementation. The generate approach has several advantages over the old method. The most notable is that previously, you had to include an empty backend configuration block in every stack, whereas with the generate approach you do not. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Chris</name></author><category term="tf-skeleton" /><category term="terraform" /><category term="terragrunt" /><summary type="html">Terraform uses state files to track the resources it creates back to resource definitions in your *.tf files. Each deployment has its own state. State is stored according to the backend configured for the deployment. Terraform uses a local backend for storing state on the local filesystem by default, which is what we’ve been using for part 1 and part 2 of the terraform skeleton series.1 This works fine for a simple demonstration but is insufficient for production use because: Terragrunt stores local state in a terraform.tfstate file located underneath the .terragrunt-cache directory it creates within our deployment directory. &amp;#8617;</summary></entry><entry><title type="html">Terraform Skeleton Part 2: Variables</title><link href="https://thirstydeveloper.io/tf-skeleton/2021/01/23/part-2-variables.html" rel="alternate" type="text/html" title="Terraform Skeleton Part 2: Variables" /><published>2021-01-23T10:53:09+00:00</published><updated>2021-01-23T10:53:09+00:00</updated><id>https://thirstydeveloper.io/tf-skeleton/2021/01/23/part-2-variables</id><content type="html" xml:base="https://thirstydeveloper.io/tf-skeleton/2021/01/23/part-2-variables.html">&lt;p&gt;In &lt;a href=&quot;/2021/01/17/part-1-organizing-terragrunt.html&quot;&gt;part 1&lt;/a&gt; of the &lt;a href=&quot;/series/tf-skeleton.html&quot;&gt;terraform skeleton series&lt;/a&gt;, we set up a &lt;a href=&quot;https://github.com/thirstydeveloper/terraform-terragrunt-skeleton/tree/release/1.0&quot;&gt;terraform repository&lt;/a&gt; that allows the team to apply infrastructure at any level: from individual stacks to entire environments. We build on that foundation in this post, adding a variable hierarchy that similarly allows definition and overriding of variables at each level of the infrastructure.&lt;/p&gt;

&lt;h1 id=&quot;goals&quot;&gt;Goals&lt;/h1&gt;

&lt;p&gt;As a refresher, our infrastructure is organized by:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tier&lt;/li&gt;
  &lt;li&gt;Environment&lt;/li&gt;
  &lt;li&gt;Layer (Optional)&lt;/li&gt;
  &lt;li&gt;Stack&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &lt;strong&gt;deployment&lt;/strong&gt; is an instantiation of a stack for a tier-environment.&lt;/p&gt;

&lt;p&gt;Today’s goals are to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Allow defining variable values in files at each level of the infrastructure&lt;/li&gt;
  &lt;li&gt;Have lower-level variable definitions override higher levels&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you prefer to jump to the end, the code implementing the final result is available on &lt;a href=&quot;https://github.com/thirstydeveloper/terraform-terragrunt-skeleton/tree/release/1.1&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;setup&quot;&gt;Setup&lt;/h1&gt;

&lt;p&gt;Let’s add to our test-stack some variables to be defined at each level of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# modules/stacks/app/test-stack/variables.tf&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;global_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unset&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;tier_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unset&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;env_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unset&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;layer_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unset&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;variable&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;stack_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unset&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s also add outputs to the stack so we can see what the variables are set to:&lt;/p&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# modules/stacks/app/test-stack/outputs.tf&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pet&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;random_pet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;global_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;global_var&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;tier_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tier_var&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;env_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;env_var&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;layer_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;layer_var&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;stack_var&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;stack_var&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, we’ll cover implementing the variable hierarchy in two ways. The first works for terraform pre-0.12. The second slightly modifies our first approach to work for 0.12+.&lt;/p&gt;

&lt;h1 id=&quot;variables-via-tfvars-pre-012&quot;&gt;Variables via tfvars (pre-0.12)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.terraform.io/docs/configuration/variables.html#variable-definitions-tfvars-files&quot;&gt;tfvars files&lt;/a&gt; are a standard way of defining variable values for terraform. Terragrunt allows you to define &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;required_var_files&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optional_var_files&lt;/code&gt; within the &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/config-blocks-and-attributes/#terraform&quot;&gt;terraform block&lt;/a&gt; of your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt.hcl&lt;/code&gt;, as covered by this &lt;a href=&quot;https://blog.gruntwork.io/terragrunt-how-to-keep-your-terraform-code-dry-and-maintainable-f61ae06959d8#d7f6&quot;&gt;Gruntwork post&lt;/a&gt;. Terragrunt then passes these files to terraform using its &lt;a href=&quot;https://www.terraform.io/docs/commands/plan.html#var-file-foo&quot;&gt;-var-file&lt;/a&gt; option. Terraform loads the files and sets the variable values, with later files overriding previous files.&lt;/p&gt;

&lt;p&gt;We can use this to implement a tfvars hierarchy. The first step is defining a tfvars file in each level of our deployments directory structure:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deployments/
    app/
        dev/
            test-stack/
                terraform.tfvars
                terragrunt.hcl
        stage/
            test-stack/
                terraform.tfvars
                terragrunt.hcl
        prod/
            test-stack/
                terraform.tfvars
                terragrunt.hcl
            terraform.tfvars
        terraform.tfvars
    terraform.tfvars
    root.hcl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, define values at each level:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# deployments/terraform.tfvars
global_var = &quot;set in deployments/&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# deployments/app/terraform.tfvars
tier_var = &quot;set in deployments/app/&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# deployments/app/dev/terraform.tfvars
env_var = &quot;set in deployments/app/dev&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# deployments/app/dev/test-stack/terraform.tfvars
stack_var = &quot;set in deployments/app/dev/test-stack/&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and so on for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/app/test/**&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/app/prod/**&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Next, we modify our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; file to load all the tfvars files. We make use of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployment_path_components&lt;/code&gt; local we defined in &lt;a href=&quot;/2021/01/17/part-1-organizing-terragrunt.html&quot;&gt;part 1&lt;/a&gt; to generate a list of all possible tfvar locations:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HCL&quot;&gt;# root.hcl
locals {
  relative_deployment_path   = path_relative_to_include()
  deployment_path_components = compact(
    split(&quot;/&quot;, local.relative_deployment_path)
  )

  ...

  # Get a list of every possible tfvars path between root_deployments_directory
  # and the path of the deployment
  possible_config_locations = [
    for i in range(0, length(local.deployment_path_components) + 1) :
      join(&quot;/&quot;, concat(
        [local.root_deployments_dir],
        slice(local.deployment_path_components, 0, i),
        [&quot;terraform.tfvars&quot;]
      ))
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, instruct terragrunt to pass the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;possible_config_locations&lt;/code&gt; as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optional_var_files&lt;/code&gt; to terraform under an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extra_arguments&lt;/code&gt; block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HCL&quot;&gt;# root.hcl
...

terraform {
  ...
  extra_arguments &quot;load_config_files&quot; {
    commands = get_terraform_commands_that_need_vars()
    optional_var_files = local.possible_config_locations
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having done this, we can run plan and apply and see the variables are loaded. For instance, running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt apply&lt;/code&gt; from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/app/dev/test-stack&lt;/code&gt; produces:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

Outputs:

env_var = set in deployments/app/dev
global_var = overridden in deployments/app
layer_var = unset
stack_var = set in deployments/app/dev/test-stack/
tier_var = set in deployments/app/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can also override values in lower levels. For instance, changing the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global_var&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/app/terraform.tfvars&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# deployments/app/terraform.tfvars
global_var = &quot;overridden in deployments/app&quot;
tier_var   = &quot;set in deployments/app/&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt output global_var&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/app/terraform.tfvars&lt;/code&gt; produces:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;overridden in deployments/app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;where-tfvars-fail&quot;&gt;Where tfvars fail&lt;/h1&gt;

&lt;p&gt;The above worked well until terraform 0.12, which introduced a &lt;a href=&quot;https://github.com/hashicorp/terraform/issues/22004&quot;&gt;controversial feature&lt;/a&gt; to print warnings when values are specified for undefined variables. For instance, if we add an unused variable to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/terraform.tfvars&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# deployments/terraform.tfvars
global_var = &quot;set-in-deployments/&quot;
unused     = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;any stack we &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply&lt;/code&gt; now prints:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Warning: Value for undeclared variable

The root module does not declare a variable named &quot;unused&quot;
but a value was found in file
&quot;/Users/td/code/td/terraform-skeleton/deployments/terraform.tfvars&quot;.
To use this value, add a &quot;variable&quot; block to the configuration.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The warnings are annoying enough in that they clutter the plan output, but worse still the warning states:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Using a variables file to set an undeclared variable is deprecated and will
become an error in a future release.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That means we can’t reliably use tfvar files as our source of a variable hierarchy for the long term, at least if you have any variables defined in tfvars that are loaded and go unused by any stacks.&lt;/p&gt;

&lt;p&gt;You might wonder if this is actually a problem. &lt;a href=&quot;https://github.com/hashicorp/terraform/blob/v0.12/CHANGELOG.md#incompatibilities-and-notes&quot;&gt;Hashicorp states&lt;/a&gt; the change was made “to give better feedback about mistakes”, so maybe we should just avoid having variables defined in tfvars files that are loaded by stacks that do not use them.&lt;/p&gt;

&lt;p&gt;Allow me to present an example where unused variables are helpful.&lt;/p&gt;

&lt;h2 id=&quot;unused-variables-a-use-case&quot;&gt;Unused variables: a use case&lt;/h2&gt;

&lt;p&gt;My team has several global flags for our infrastructure. An example is one used to conditionally enable or disable access to our system for a third-party team. Any stack that must make changes to facilitate that access defines an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enable_third_party_access&lt;/code&gt; variable in its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;variables.tf&lt;/code&gt; file. If true, that stack makes the necessary changes.&lt;/p&gt;

&lt;p&gt;Multiple stacks defining this variable poses a challenge. When third-party access is requested, we don’t want to have to find every deployment of every stack with this variable and set its value to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;true&lt;/code&gt;. We want to define the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enable_third_party_access&lt;/code&gt; once, either across all environments or for specific environments, so we don’t forget to enable or disable individual flags. Furthermore, not every stack needs to enable third-party access, and therefore not every stack needs this variable.&lt;/p&gt;

&lt;p&gt;Leveraging unused variables means we can set the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enable_third_party_access&lt;/code&gt; value in fewer places, leading to fewer mistakes.&lt;/p&gt;

&lt;p&gt;There are plenty more examples of how unused variables are useful in the &lt;a href=&quot;https://github.com/hashicorp/terraform/issues/22004&quot;&gt;Hashicorp issue discussion&lt;/a&gt;. So how do we support unused variables in 0.12 and beyond?&lt;/p&gt;

&lt;h1 id=&quot;variables-via-yaml-012&quot;&gt;Variables via YAML (0.12+)&lt;/h1&gt;

&lt;p&gt;Fortunately, Hashicorp does give you a workaround for defining values for unused variables, also displayed in the warning messages they print:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If you wish to provide certain &quot;global&quot; settings to all configurations in
your organization, use TF_VAR_... environment variables to set these instead.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So instead of using tfvar files, we need to define environment variables. But how can we do that easily and  reproducibly across systems? Terragrunt again comes to the rescue.&lt;/p&gt;

&lt;p&gt;We can pass an HCL map to an &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/features/inputs/&quot;&gt;inputs&lt;/a&gt; attribute in our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt;, which terragrunt converts to TF_VAR environment variables passed to terraform. Now we just need a map of our variables and their values. There’s no easy way to generate such a map from tfvars files, but terragrunt &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/built-in-functions/#terraform-built-in-functions&quot;&gt;provides access&lt;/a&gt; to all of &lt;a href=&quot;https://www.terraform.io/docs/configuration/functions.html&quot;&gt;terraform’s functions&lt;/a&gt; in the HCL file. This gives us the building blocks we need to use YAML files instead of tfvars to build our variable hierarchy. Specifically, we’ll use:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/docs/configuration/functions/fileexists.html&quot;&gt;fileexists&lt;/a&gt; - for checking if a file exists before attempting to load it&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/docs/configuration/functions/file.html&quot;&gt;file&lt;/a&gt; - for loading file contents to a string&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/docs/configuration/functions/yamldecode.html&quot;&gt;yamldecode&lt;/a&gt; - for converting a YAML string to an HCL map&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.terraform.io/docs/configuration/functions/merge.html&quot;&gt;merge&lt;/a&gt; - for merging multiple HCL maps&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Start by converting the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform.tfvars&lt;/code&gt; files to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;config.yml&lt;/code&gt; files&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. For instance, convert:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# deployments/terraform.tfvars
global_var = &quot;set-in-deployments/&quot;
unused     = true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-YAML&quot;&gt;# deployments/config.yml
---
global_var: &quot;set-in-deployments/&quot;
unused: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, modify &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; to load the YAML files, first by removing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extra_arguments&lt;/code&gt; block we used for loading the tfvars:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HCL&quot;&gt;# root.hcl
...
terraform {
  source = &quot;${local.root_deployments_dir}/../modules/stacks/${local.tier}/${local.stack}&quot;
  # no extra_arguments block here
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then by changing the locals to load the YAML files and pass them into the terragrunt inputs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HCL&quot;&gt;# root.hcl
locals {
  ...

  # Get a list of every path between root_deployments_directory and the path of
  # the deployment
  possible_config_dirs = [
    for i in range(0, length(local.deployment_path_components) + 1) :
      join(&quot;/&quot;, concat(
        [local.root_deployments_dir],
        slice(local.deployment_path_components, 0, i)
      ))
  ]

  # Generate a list of possible config files at every possible_config_dir
  # (support both .yml and .yaml)
  possible_config_paths = flatten([
    for dir in local.possible_config_dirs : [
      &quot;${dir}/config.yml&quot;,
      &quot;${dir}/config.yaml&quot;
    ]
  ])

  # Load every YAML config file that exists into an HCL map
  file_configs = [
    for path in local.possible_config_paths :
      yamldecode(file(path)) if fileexists(path)
  ]

  # Merge the maps together, with deeper configs overriding higher configs
  merged_config = merge(local.file_configs...)
}

# Pass the merged config to terraform as variable values using TF_VAR_
# environment variables
inputs = local.merged_config

...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that’s it. We have a YAML-based variable hierarchy that supports overriding and unused variables. The final result is available on &lt;a href=&quot;https://github.com/thirstydeveloper/terraform-terragrunt-skeleton/tree/release/1.1&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h1&gt;

&lt;p&gt;So far, the skeleton has been using the default &lt;a href=&quot;https://www.terraform.io/docs/backends/types/local.html&quot;&gt;local backend&lt;/a&gt; for state storage. For this project to work in a team setting with multiple developers and/or CI/CD performing terraform commands, we will need to store terraform state remotely with locking to avoid concurrent executions from stepping on each other. Setting up remote state storage will be the subject of the next post.&lt;/p&gt;

&lt;h1 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h1&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;The YAML loading doesn’t play nice with config.yml files that are empty or contain just a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;---&lt;/code&gt; start of document marker. You can delete the empty &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;config.yml&lt;/code&gt; file and everything will work, due to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fileexists&lt;/code&gt; check. If you prefer to keep the empty config.yml, the most minimal contents required are:&lt;/p&gt;

      &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---
{}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;      &lt;/div&gt;
      &lt;p&gt;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Chris</name></author><category term="tf-skeleton" /><category term="terraform" /><category term="terragrunt" /><summary type="html">In part 1 of the terraform skeleton series, we set up a terraform repository that allows the team to apply infrastructure at any level: from individual stacks to entire environments. We build on that foundation in this post, adding a variable hierarchy that similarly allows definition and overriding of variables at each level of the infrastructure.</summary></entry><entry><title type="html">Terraform Skeleton Part 1: Organizing Terragrunt</title><link href="https://thirstydeveloper.io/2021/01/17/part-1-organizing-terragrunt.html" rel="alternate" type="text/html" title="Terraform Skeleton Part 1: Organizing Terragrunt" /><published>2021-01-17T12:23:00+00:00</published><updated>2021-01-17T12:23:00+00:00</updated><id>https://thirstydeveloper.io/2021/01/17/part-1-organizing-terragrunt</id><content type="html" xml:base="https://thirstydeveloper.io/2021/01/17/part-1-organizing-terragrunt.html">&lt;p&gt;&lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt; is my go-to infrastructure definition tool. I love that it enables declarative management of different Cloud, PaaS, and SaaS platforms with its unified HCL language and provider model. At times, however, I’ve wished it was easier to start a project off on the right foot.&lt;/p&gt;

&lt;p&gt;When I was getting started, it wasn’t obvious to me how to organize a terraform project in a way that makes “the easy things easy and the hard things possible” and would scale well as a team grows. &lt;a href=&quot;https://terragrunt.gruntwork.io/&quot;&gt;Terragrunt&lt;/a&gt; helps a great deal, but there are many configuration options, adding to the organizational complexity.&lt;/p&gt;

&lt;p&gt;This blog series takes lessons learned from using terraform and terragrunt in production across multiple teams and, over many posts, condenses those lessons into a &lt;a href=&quot;https://github.com/thirstydeveloper/terraform-terragrunt-skeleton&quot;&gt;walking skeleton repo&lt;/a&gt; to serve as a starting point for teams working with terraform and terragrunt. I’ve used this skeleton’s approach for a moderately complex suite of applications spanning multiple clouds and multiple Kubernetes clusters. I’m also using it with a smaller team running a much simpler monolith application. I believe it is a solid starting point, worth sharing with others for consideration.&lt;/p&gt;

&lt;p&gt;I’m using semantic versioning to track changes to the skeleton repo. This post covers major-minor version 1.0. The code this post arrives at is available on the release branch for that version &lt;a href=&quot;https://github.com/thirstydeveloper/terraform-terragrunt-skeleton/tree/release/1.0&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;goals&quot;&gt;Goals&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;Version control all infrastructure as code&lt;/li&gt;
  &lt;li&gt;Provide a basic safety net of explicit tool versions and pre-commit checks&lt;/li&gt;
  &lt;li&gt;Re-use the same infrastructure definition files across multiple environments&lt;/li&gt;
  &lt;li&gt;Have multiple levels of blast radiuses; allow the engineer to easily apply a small stack of infrastructure or an entire environment&lt;/li&gt;
  &lt;li&gt;Focus on manual infrastructure deployment for now. Continuous Integration will follow. Continuous Delivery will be case-by-case.&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;setup&quot;&gt;Setup&lt;/h1&gt;

&lt;p&gt;You’ll need the following installed on your workstation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tfutils/tfenv&quot;&gt;tfenv&lt;/a&gt; for managing terraform versions&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/cunymatthieu/tgenv&quot;&gt;tgenv&lt;/a&gt; for managing terragrunt versions&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pre-commit.com/&quot;&gt;pre-commit&lt;/a&gt; for running syntax, semantic, and style checks on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;the-infra-repo&quot;&gt;The ‘infra’ repo&lt;/h1&gt;

&lt;p&gt;I currently start teams off with a monorepo structure for terraform infrastructure. I admit that having one or more separate modules repositories, as &lt;a href=&quot;https://www.terraformupandrunning.com/&quot;&gt;Terraform Up &amp;amp; Running&lt;/a&gt; advises, is a good destination, but my teams have found it easier to get started making changes within a single repository. The organization that follows works both with mono and distributed repositories, however. Teams I support have made the jump from monorepo to distributed, and it was not painful.&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Our team calls our monorepo &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;infra&lt;/code&gt;, and that’s the name I will use here.&lt;/p&gt;

&lt;h2 id=&quot;step-1-boilerplate&quot;&gt;Step 1: Boilerplate&lt;/h2&gt;

&lt;p&gt;After installing the tools listed above and creating a new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;infra&lt;/code&gt; repository:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Create a CHANGELOG.md&lt;/p&gt;

    &lt;p&gt;I like the style of &lt;a href=&quot;https://keepachangelog.com/en/1.0.0/&quot;&gt;keepachangelog.com&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add a .gitignore&lt;/p&gt;

    &lt;p&gt;I use &lt;a href=&quot;https://www.toptal.com/developers/gitignore&quot;&gt;gitignore.io&lt;/a&gt; as a &lt;a href=&quot;https://www.toptal.com/developers/gitignore/api/terraform,terragrunt&quot;&gt;starting point&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Set tool versions&lt;/p&gt;

    &lt;p&gt;For instance, if using terraform 0.13.5 and terragrunt 0.26.4 set the versions with:&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0.13.5&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; .terraform-version
 &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0.26.4&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; .terragrunt-version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Then install the versions with:&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; tfenv &lt;span class=&quot;nb&quot;&gt;install
 &lt;/span&gt;tgenv &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Commit and update your changelog accordingly e.g.,&lt;/p&gt;

    &lt;div class=&quot;language-markdown highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ## [Unreleased]

 ### Added
&lt;span class=&quot;p&quot;&gt; -&lt;/span&gt; terraform version set to 0.13.5
&lt;span class=&quot;p&quot;&gt; -&lt;/span&gt; terragrunt version set to 0.26.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install pre-commit hooks&lt;/p&gt;

    &lt;p&gt;These hooks provide a safety net that gets executed on each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit&lt;/code&gt;. I’d start with at least the following:&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/antonbabenko/pre-commit-terraform&quot;&gt;terraform_fmt hook&lt;/a&gt; formats *.tf files using the &lt;a href=&quot;https://www.terraform.io/docs/commands/fmt.html&quot;&gt;terraform fmt&lt;/a&gt; command&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/antonbabenko/pre-commit-terraform&quot;&gt;terraform_validate&lt;/a&gt; similarly runs &lt;a href=&quot;https://www.terraform.io/docs/commands/validate.html&quot;&gt;terraform validate&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/gruntwork-io/pre-commit&quot;&gt;terragrunt-hclfmt&lt;/a&gt; runs &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/cli-options/#hclfmt&quot;&gt;terragrunt hclfmt&lt;/a&gt; on terragrunt.hcl files&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;You specify these in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.pre-commit-config.yaml&lt;/code&gt; file. &lt;a href=&quot;https://github.com/thirstydeveloper/terraform-terragrunt-skeleton/blob/release/1.0/.pre-commit-config.yaml&quot;&gt;Here’s&lt;/a&gt; what it looks like.&lt;/p&gt;

    &lt;p&gt;Next, run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pre-commit install&lt;/code&gt; to install the hooks.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;step-2-directory-structure&quot;&gt;Step 2: Directory Structure&lt;/h2&gt;

&lt;p&gt;Covering the directory structure introduces a lot of terms. I start with two top-level directories:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deployments/
modules/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;deployments&quot;&gt;Deployments&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;deployments&lt;/strong&gt; are instantiations of infrastructure. Directories under deployments contain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt.hcl&lt;/code&gt; files. You run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt&lt;/code&gt; commands inside deployment directories.&lt;sup id=&quot;fnref:5&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Deployments are organized in a directory tree. The first level in the tree is the infrastructure &lt;strong&gt;tiers&lt;/strong&gt;. Small projects may just have a single tier of infrastructure. For larger projects, there are often multiple tiers relying or building on each other. Sometimes these tiers are managed by different teams. For instance, my team has a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foundation&lt;/code&gt; tier containing shared services like our docker image registry and CI/CD tooling, and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;service&lt;/code&gt; tier containing application infrastructure:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deployments/
    foundation/
    service/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each tier consists of one or more instantiations called &lt;strong&gt;environments&lt;/strong&gt;. For instance: development, staging, and production.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deployments/
    foundation/
        dev/
        stage/
        prod/
    service/
        dev/
        stage/
        prod/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Underneath each environment, you have &lt;strong&gt;stacks&lt;/strong&gt; and/or &lt;strong&gt;layers&lt;/strong&gt; of stacks that make up that tier-environment. Layers are optional directories grouping stacks together. Stacks are bundles of infrastructure that are managed as a unit using terragrunt commands.&lt;/p&gt;

&lt;p&gt;For instance, our foundation tier might consist of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;network&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k8s&lt;/code&gt; stack, and a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jenkins&lt;/code&gt; stack underneath an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apps&lt;/code&gt; layer:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deployments/
    foundation/
        dev/
            network/
                terragrunt.hcl
            k8s/
                terragrunt.hcl
            apps/
                jenkins/
                    terragrunt.hcl
    root.hcl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Bringing it all together, each &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployment&lt;/code&gt; is an instantiation of a stack for a tier-environment. For example, the jenkins stack for the foundation tier’s dev environment, which my team would summarize as foundation-dev-jenkins. To manage foundation-dev-jenkins, you run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt&lt;/code&gt; commands from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/foundation/dev/apps/jenkins&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;Deployment directories do not contain the infrastructure definition (.tf) files themselves, however. Instead, each deployment references a stack underneath &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/stacks/&lt;/code&gt;. This allows us to have a single stack definition deployed multiple times - across multiple environments for example.&lt;/p&gt;

&lt;h3 id=&quot;modules&quot;&gt;Modules&lt;/h3&gt;

&lt;p&gt;Expanding modules I have:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deployments/
modules/
    components/
    stacks/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;stacks&lt;/strong&gt; are root &lt;a href=&quot;https://www.terraform.io/docs/configuration/modules.html&quot;&gt;terraform modules&lt;/a&gt; and group together infrastructure that is managed as a unit. Stacks are defined as directories under &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/stacks/&lt;/code&gt;, organized by tier, and contain the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tf&lt;/code&gt; files defining the stack’s infrastructure. Using our foundation example from above, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/stacks&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;modules/
    stacks/
        foundation/
            network/
                ...
            k8s/
                ...
            jenkins/
                main.tf
                outputs.tf
                providers.tf
                variables.tf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Stacks may contain terraform provider resources directly (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aws_s3_bucket&lt;/code&gt;), but often will contain child terraform modules, which I call &lt;strong&gt;components&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Any components specific to this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;infra&lt;/code&gt; repository reside in directories under &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/components&lt;/code&gt;, and those directories similarly contain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tf&lt;/code&gt; files defining the infrastructure belonging to the component. For example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;modules/
    components/
        some-component/
            main.tf
            variables.tf
            outputs.tf
        another-component/
            ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Summarized, each &lt;strong&gt;deployment&lt;/strong&gt; references a &lt;strong&gt;stack&lt;/strong&gt;, and each &lt;strong&gt;stack&lt;/strong&gt; may instantiate any number of &lt;strong&gt;components&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;You probably noticed the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt.hcl&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; files in the example above. Let’s talk about those next.&lt;/p&gt;

&lt;h2 id=&quot;step-3-hcl-files&quot;&gt;Step 3: HCL files&lt;/h2&gt;

&lt;p&gt;Each deployment contains a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt.hcl&lt;/code&gt; file, marking it as a stack to be deployed with terragrunt. They are usually extremely simple, only containing an include to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; file.&lt;sup id=&quot;fnref:6&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HCL&quot;&gt;# terragrunt.hcl
include {
  path = find_in_parent_folders(&quot;root.hcl&quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; file contains all the terragrunt configuration. A simple starting point is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-HCL&quot;&gt;# root.hcl
locals {
  root_deployments_dir       = get_parent_terragrunt_dir()
  relative_deployment_path   = path_relative_to_include()
  deployment_path_components = compact(split(&quot;/&quot;, local.relative_deployment_path))

  tier  = local.deployment_path_components[0]
  stack = reverse(local.deployment_path_components)[0]
}

# Default the stack each deployment deploys based on its directory structure
# Can be overridden by redefining this block in a child terragrunt.hcl
terraform {
  source = &quot;${local.root_deployments_dir}/../modules/stacks/${local.tier}/${local.stack}&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes it so each deployment directory, by default, deploys the stack under &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/stacks/&amp;lt;tier&amp;gt;&lt;/code&gt; with the same name as the deployment directory. For instance, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/foundation/dev/apps/jenkins/&lt;/code&gt; deploys &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;modules/stacks/foundation/jenkins&lt;/code&gt;.&lt;sup id=&quot;fnref:7&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; I haven’t decided if I like making the layer part of that path or not, so thus far have left it out.&lt;/p&gt;

&lt;p&gt;With an understanding of the tools, directory structure, and HCL files, we can put together a minimal skeleton repo.&lt;/p&gt;

&lt;h2 id=&quot;step-4-the-skeleton&quot;&gt;Step 4: The Skeleton&lt;/h2&gt;

&lt;p&gt;Here’s a minimal skeleton I would start with, not including boilerplate files:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deployments/
    app/
        dev/
            test-stack/
                terragrunt.hcl
        stage/
            test-stack/
                terragrunt.hcl
        prod/
            test-stack/
                terragrunt.hcl
    root.hcl
modules/
    components/
    stacks/
        app/
            test-stack/
                main.tf
                outputs.tf
                providers.tf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our basic test-stack could use the &lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/random/3.0.0&quot;&gt;random provider&lt;/a&gt; to create a single resource and output:&lt;/p&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# main.tf&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;random_pet&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pet&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# outputs.tf&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;pet&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;random_pet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;pet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-terraform highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# providers.tf&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;terraform&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;required_providers&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;random&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;source&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hashicorp/random&quot;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;~&amp;gt; 3.0.0&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this in place, we can run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt plan&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt apply&lt;/code&gt; from any directory under &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/&lt;/code&gt;. We can also run &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/cli-options/#plan-all&quot;&gt;plan-all&lt;/a&gt; and &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/cli-options/#apply-all&quot;&gt;apply-all&lt;/a&gt; from:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The root of the repository to affect all tiers and all environments&lt;/li&gt;
  &lt;li&gt;Any directory within deployments to affect everything underneath that directory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We can also use &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/cli-options/#terragrunt-exclude-dir&quot;&gt;–terragrunt-exclude-dir&lt;/a&gt; and &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/cli-options/#terragrunt-include-dir&quot;&gt;–terragrunt-include-dir&lt;/a&gt; to target &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*-all&lt;/code&gt; commands. For example:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt apply-all --terragrunt-exclude-dir deployments/*/prod/**&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;would apply all non-production environments across all tiers.&lt;/p&gt;

&lt;h1 id=&quot;whats-next&quot;&gt;What’s next?&lt;/h1&gt;

&lt;p&gt;This skeleton is quite minimal. We haven’t covered variables, backends, RBAC, external modules, build tooling, continuous integration, and so on.&lt;/p&gt;

&lt;p&gt;The next post will dive deeper into what we can do with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt;, including introducing a variable loading hierarchy that makes our deployments easier to work with.&lt;/p&gt;

&lt;h1 id=&quot;footnotes&quot;&gt;Footnotes&lt;/h1&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In short, CI/CD with terraform is tricky. The authors of terragrunt discuss some of the challenges &lt;a href=&quot;https://github.com/gruntwork-io/terragrunt/issues/720#issuecomment-497888756&quot;&gt;here&lt;/a&gt;. I’m a proponent of pushing CI/CD for infrastructure, but doing so carefully and expecting times of manual intervention. Some things are difficult to automate out of the box - state migrations (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terraform state mv&lt;/code&gt;) being one example. I’ve trended towards starting teams off with CI and manual applies of infrastructure and working towards CD as the team becomes more comfortable. More on CI/CD in future posts. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Terraform stores its state in state files and those state files contain the version of terraform last used. The version specified in the state file is auto-bumped whenever a newer version of terraform touches that state file. Once that happens, you may force anyone working on that infrastructure, &lt;em&gt;or relying on outputs&lt;/em&gt; from your state file via &lt;a href=&quot;https://www.terraform.io/docs/providers/terraform/d/remote_state.html&quot;&gt;terraform_remote_state&lt;/a&gt; data sources to upgrade. The second case is the most damaging because it can affect teams outside of your own, depending on who’s using your outputs. &lt;a href=&quot;https://github.com/hashicorp/terraform/blob/v0.14/CHANGELOG.md&quot;&gt;terraform 0.14&lt;/a&gt; addresses this, making state files backward and forward compatible across terraform versions as much as possible, but anyone using older versions of terraform should be particularly careful with terraform versioning. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;We’ve since split our infrastructure across multiple repositories, but only after demonstrated needs: distributed ownership, differing change/release rates, and re-use across teams. Much like &lt;a href=&quot;https://martinfowler.com/bliki/MonolithFirst.html&quot;&gt;starting with a monolith&lt;/a&gt; before evolving to microservices, starting with an infra monorepo avoids bloat slowing your team unnecessarily. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;

      &lt;p&gt;There are lots of other tools/hooks that are worth looking at that I haven’t had time to yet. Some on my list to explore include:&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&quot;https://github.com/tfsec/tfsec&quot;&gt;tfsec&lt;/a&gt; - example &lt;a href=&quot;https://github.com/antonbabenko/pre-commit-terraform&quot;&gt;hook&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://github.com/terraform-docs/terraform-docs&quot;&gt;terraform docs&lt;/a&gt; - example &lt;a href=&quot;https://github.com/antonbabenko/pre-commit-terraform&quot;&gt;hook&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://github.com/terraform-linters/tflint&quot;&gt;tflint&lt;/a&gt; - example &lt;a href=&quot;https://github.com/antonbabenko/pre-commit-terraform&quot;&gt;hook&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;https://www.checkov.io/&quot;&gt;checkov&lt;/a&gt; - official &lt;a href=&quot;https://www.checkov.io/4.Integrations/pre-commit.html&quot;&gt;hook&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;&lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;If you’ve read &lt;a href=&quot;https://www.terraformupandrunning.com/&quot;&gt;Terraform Up &amp;amp; Running&lt;/a&gt;, my &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/&lt;/code&gt; directory equates to Yevgeniy’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;live/&lt;/code&gt; directory. My team just found the name deployments to be more understandable. &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I use the name &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root.hcl&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;terragrunt.hcl&lt;/code&gt; because the latter causes errors running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;plan-all&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply-all&lt;/code&gt; from the root or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;deployments/&lt;/code&gt; directory. Terragrunt seems to treat the parent hcl file as a stack to be deployed and errors out. I tried terragrunt’s &lt;a href=&quot;https://terragrunt.gruntwork.io/docs/reference/config-blocks-and-attributes/#skip&quot;&gt;skip option&lt;/a&gt; but to no avail, at least as of version 0.26.2 &lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:7&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Terragrunt glues the deployment to the stack definition by copying everything in the deployment directory and everything in the referenced stack directory (containing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.tf&lt;/code&gt; files) into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.terragrunt-cache&lt;/code&gt; directory and then executing commands from that directory. By default, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.terragrunt-cache&lt;/code&gt; directory lives in your deployment directory. &lt;a href=&quot;#fnref:7&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Chris</name></author><category term="tf-skeleton" /><category term="terraform" /><category term="terragrunt" /><summary type="html">Terraform is my go-to infrastructure definition tool. I love that it enables declarative management of different Cloud, PaaS, and SaaS platforms with its unified HCL language and provider model. At times, however, I’ve wished it was easier to start a project off on the right foot.</summary></entry></feed>